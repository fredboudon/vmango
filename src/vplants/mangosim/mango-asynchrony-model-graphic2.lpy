from transfert_mtg_to_lpy import *
tree,charge, name = cogshall_trees[TREE]
# 0 : "B14", 1 : "F2", 2 : "F6" , 3 : "B10", 4 : "B12"
loaded = True if charge=='C' else False
line_trunk = tree + 3

#assert TREE==2

labels = {
        0: "U-V", # Vegetative, unknown flush
        1: "II-V", # Vegetative, immediate flush 1 (very rare) or 2
        2: "IL-V", # Vegetative, immediate flush 3
        3: "DE-V", # Vegetative, one-year delayed flush 1
        4: "DI-V", # Vegetative, one-year delayed flush 2
        5: "DL-V", # Vegetative, one-year delayed flush 3
        6: "U-F",  # Flowering with unknown position of flower, unknown flush (only possibility for flushes)
        7: "II-T", # Terminal flower and no lateral flower, immediate flush 2 
        8: "IL-T", # Terminal flower and no lateral flower, immediate flush 3 
        9: "DI-T", # Terminal flower and no lateral flower, one-year delayed flush 1 (very rare) or 2
        10: "DL-T", # Terminal flower and no lateral flower, one-year delayed flush 3
        11: "II-L", # "Lateral flower", immediate flush 2 or 3 (rare)
        12: "DI-L"  # "Lateral flower", one-year delayed (mostly flush 2)
}

from vplants.statistic import *
from vplants import mangostat
from openalea.deploy.shared_data import shared_data
path = shared_data(mangostat, share_path='share')
if MIXTURE :
  if loaded :
    dist = load(path/'mtbp'/'dag'/'not_thinned'/'mixture'/'cogshall.dst')
    states = load(path/'mtbp'/'dag'/'not_thinned'/'mixture'/'cogshall.lst')
  else : 
    dist = load(path/'mtbp'/'dag'/'thinned'/'mixture'/'cogshall.dst')
    states = load(path/'mtbp'/'dag'/'thinned'/'mixture'/'cogshall.lst')
else:
  if loaded:
    if IDENTITY_LINK :
      dist = load(path/'mtbp'/'dag'/'not_thinned'/'no_mixture'/'cogshall-bis.dst')
    else :
      dist = load(path/'mtbp'/'dag'/'not_thinned'/'no_mixture'/'cogshall.dst')
    states = load(path/'mtbp'/'dag'/'not_thinned'/'no_mixture'/'cogshall.lst')
  else:
    dist = load(path/'mtbp'/'dag'/'thinned'/'no_mixture'/'cogshall.dst')
    states = load(path/'mtbp'/'dag'/'thinned'/'no_mixture'/'cogshall.lst')




from openalea.plantgl.all import Text
from datetime import date, timedelta
from math import floor, ceil
from mango_state_simulation import *

first_date = date(2003,5,15)
last_date = date(2005,11,1)

order_max = 10
total_weeks = ceil((last_date -first_date).days/7.)
daystep = 7
nbsteps = ceil((last_date -first_date).days/float(daystep))
current_date = first_date


nature = None
vegetative , inflorescence = range(2)
no_sons = 20
def Start():
  global current_date
  current_date = first_date

def EndEach():
  global current_date
  current_date += timedelta(days = 7)

def End(lstring):
  if EXPORT_MTG:
    export_to_mtg(lstring)

def export_to_mtg(lstring):
  from openalea.mtg.io import axialtree2mtg
  from cPickle import dump,HIGHEST_PROTOCOL
  parameters = {}
  scales = {}
  # Name of the modules to export
  modules_to_export = ['B_UC','UC','Flower']
  # Set the 
  for m in modules_to_export:
    mod = ModuleClass.get(m)
    scales[m] = 1 # All element will be at the same scale
    parameters[m] = mod.parameterNames # get the parameter from module definition in line 87 - 93
  # Convert lstring into mtg
  mtg = axialtree2mtg(lstring,scales,None,parameters)
  # write it in the file
  dump(mtg,open('mango_asynchrony_graphic_model.bmtg','wb'),HIGHEST_PROTOCOL)

module B(line,order_k)
module B_UC(order_k)
module A(flushdate, order, state) # represent bud of the plant
module UC(burst_date, order, nature)
module LeafSets(lradius, age, scale)
module Flower(burst_date,order) # represent flower
module FlowerRepr(day_age,s)



Axiom: G B(line_trunk,0)

derivation length: int(total_weeks)
production:

decomposition:
maximum depth : order_max


B(vertice,order_k):
  nproduce /(144) B_UC(order_k)
  Pchilds,Mchilds = get_children_P_M(vertice)
  if len(Pchilds) > 0 : 
    apical, lateral = get_apical_lateral_position(Pchilds)
    if len(lateral) > 0:
      for nb in range(1,len(lateral)+1):
        nproduce /(360./(len(lateral) ) )[&(70) @Gc B(lateral[nb-1],order_k+1)] @Ge
    if apical != None:
      produce B(apical,order_k+1)
  if len(Mchilds) > 0:
    apical, lateral = get_apical_lateral_position(Mchilds)
    if len(lateral) > 0:
      for nb in range(1,len(lateral)+1):
        nature_bud = get_nature_2003(lateral[nb-1])
        nproduce /(360./(len(lateral) ) )[&(70) @Gc A(date(2003,5,15),order_k+1, nature_bud)] @Ge
    if apical !=None:
      nature_bud = get_nature_2003(apical)
      produce A(date(2003,5,15),order_k+1, nature_bud)


production:



A(burst_date, order, state):
  if  burst_date <= current_date :
    burst_date = current_date
    nature_father = get_nature(state) # gives the nature self (vegetative or inflorescence)  
    if state == "V" or state == "F":
      nproduce /(144) B_UC(order)
    else:
      nproduce /(144) UC(burst_date, order, nature_father )
    sons = dist[state].simulate() # calculates sons' number for a state
    dict_sons = dict(zip(states,sons))
    nb_lateral_flowers = get_nb_lateral_flowers(state)
    total_sons = sum(sons) + nb_lateral_flowers # gives total numbers of sons & possible nb of lateral flower
    
    if total_sons > 1:
      if nature_father == inflorescence:
        anglebetweensons = 360./(total_sons)
      else:
        anglebetweensons = 360./(total_sons-1)
    else:
      anglebetweensons = 0
    
    if nature_father == inflorescence:
      for sons_state in late2early:
        if dict_sons[sons_state] > 0:
          date_sons = get_date(sons_state,current_date,LAW_DATE, SELECT_TREE, name, loaded)
          if dict_sons[sons_state] > 1:
            for i in range(1,dict_sons[sons_state]+1):
              nproduce /(anglebetweensons) [&(60) A(date_sons,order+1, sons_state)]
          elif dict_sons[sons_state] == 1:
            nproduce /(anglebetweensons) [&(60) A(date_sons,order+1, sons_state)]
      if state != 'F' : 
        date_flowers = get_date_flowers(current_date,loaded) 
        if nb_lateral_flowers > 0:
          for i in range(1, nb_lateral_flowers+1):
            nproduce /(anglebetweensons) [&(60) Flower(date_flowers,order+1)]
        produce Flower(date_flowers,order+1)
      else : 
        produce Flower(date(2003,9,15),order+1)
    
    elif nature_father == vegetative:
      apical_state, lateral_states = get_apical_state(sons)
      if len(lateral_states) > 0:
        for sons_state in lateral_states: # for each state in lateral position do
          date_sons = get_date(sons_state,current_date,LAW_DATE, SELECT_TREE, name, loaded) # calculate the burst date of the son 
          if dict_sons[sons_state] > 1:
            for i in range(1,dict_sons[sons_state]+1):
              nproduce /(anglebetweensons) [&(60) A(date_sons,order+1, sons_state)]
          elif dict_sons[sons_state] == 1:
            nproduce /(anglebetweensons) [&(60) A(date_sons,order+1, sons_state)]
      if not apical_state is None :
        date_sons = get_date(apical_state,current_date,LAW_DATE, SELECT_TREE, name, loaded) # calculate the burst date of the apical son
        if dict_sons[apical_state] > 1:
          for i in range(1,dict_sons[apical_state]):
             nproduce /(anglebetweensons) [&(60) A(date_sons,order+1, apical_state)]
        produce A(date_sons,order+1, apical_state)

Flower(x,o):
  day_age = (current_date - x).days
  flower_max_age = 60
  if day_age > flower_max_age and not EXPORT_MTG:
    produce *

interpretation:
maximum depth: 10

B_UC(order_k):
  week_age =( current_date-first_date).days/7
  lradius1 = radius(min(1.,1.-(week_age/ float(total_weeks))))  
  
  color = 1
  lradius =  radius_base03( order_k/float(order_max) )
  scale = 1.5
  ds = scale/10
  nproduce ,(color) _(lradius+lradius1) @Gc nF(scale,ds,lradius+lradius1) @Ge


UC(x,o,n):
  day_age = (current_date - x).days
  week_age = day_age/7
  
  lradius = radius(min(1.,1.-(week_age/ float(total_weeks))))
  scale = 1
  produce ,(2) _(lradius) LeafSets(lradius, week_age, scale)

LeafSets(lradius, age, scale):
  ds = scale / 10.
  if LEAFY and age < 56 :
    phy = 137.5
    nproduce @Gc  F(ds) Leaf(0,lradius, leafsize(0.1), scale ) 
    nbleaf, dl = (ceil((scale-ds)*5),2*ds)
    for i in xrange(1,int(nbleaf)):
      nproduce nF(dl,ds) Leaf(phy*i,lradius, leafsize(0.1+0.1*i ), scale )
    nproduce F(ds) @Ge
    for i in xrange(1,4):
      nproduce Leaf(phy*i,lradius, leafsize(1),scale )
  else:
    produce  @Gc nF(1,0.1) @Ge

Flower(x,o) :
  day_age = (current_date - x).days
  produce FlowerRepr(day_age, x.year+x.month+x.day)

FlowerRepr(day_age,s) :
  growth_duration = 21.
  flower_growth_duration = 21.
  scale = min(1,day_age/growth_duration)
  if LEAFY:
    import random as rd
    rdstate = rd.getstate()
    rd.seed(s)
    flower_radius = 0 if day_age < growth_duration else 0.04*min(1,(day_age-flower_growth_duration)/flower_growth_duration)
    nproduce [
    if day_age > growth_duration :  nproduce @Tp(0,0,-1) @Ts(inflo_elasticity(min(1,(day_age-growth_duration)/40.))) 
    nproduce ,(3) _(0.01) F(0.1)
    nbflower = 4
    nbelem = int(floor(10 * scale))
    for i in xrange(10-nbelem,10):
       nproduce    F(0.1) [ /(randint(0,180))
       for j in xrange(nbflower):
           nproduce [ /(j*90)  &(randint(70,110)) F(inflo_radius(i*0.1)) 
           if flower_radius > 0: nproduce ,(4) @O(flower_radius) 
           nproduce ]
       nproduce ]
    nproduce ,(3) F(0.1)
    if flower_radius > 0: nproduce ,(4) @O(0.04) 
    nproduce ]
    rd.setstate(rdstate)
  else:
    scale = 0.3
    produce ,(4) _(inflo_radius(0))F(scale,inflo_radius(1))

# Setup  tropism and legend
# Note that the 2D legend cause a crash of lpy when recording the animation
G --> @Tp(0,0,1) @Ts(Elasticity) #[ -(90),(3) f(2) @g(Text('date: '+str(current_date),(5,5,0.9),True))] 

Leaf(angle, radius, length, scale ) --> [ /(angle) &(90)  f(radius) @Ge @Gc @v &(10) Sweep(leafpath,leafsection,length*scale,length*scale/10,scale,leafdiam)]


endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_1 = pgl.Material("Color_1" , ambient = (65,45,15) , diffuse = 1.58462 , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	context.options.setSelection('Early return when no matching',0)
	scalars = [('TREE', 3, 0, 4), ('EXPORT_MTG', True), ('Choice of graph', None), ('IDENTITY_LINK', False), ('MIXTURE', False), ('Distribution burst date GU', None), ('LAW_DATE', 2, 0, 2), ('SELECT_TREE', True), ('Geometry', None), ('LEAFY', True), ('Elasticity', 0.03, 0.0, 1.0, 2)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] is None : context[s[0]] = s[1]
	import openalea.plantgl.all as pgl
	leafsize = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.431282, 1),(0.324129, 0.436757, 1),(0.408886, 0.416427, 1),(0.412274, 0.708684, 1),(0.844357, 0.703533, 1),(1, 0.246499, 1)]) , 
	    )
	leafsize.name = "leafsize"
	import openalea.plantgl.all as pgl
	leafpath = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.5, 0, 1),(-0.145022, -0.0735931, 1),(0.0844156, -0.212121, 1),(0.123377, -0.497835, 1)]) , 
	    )
	leafpath.name = "leafpath"
	leafsection = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.201299, 0.231602, 1),(-0.253247, 0.181818, 1),(-0.166667, 0, 1),(-0.0196652, -0.0165724, 1),(0.00408221, 0.0220172, 1),(0.0454545, -0.0151515, 1),(0.214286, -0.012987, 1),(0.383117, 0.164502, 1),(0.344156, 0.24026, 1)]) , 
	    )
	leafsection.name = "leafsection"
	leafdiam = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.017316, 1),(0.167909, 0.309417, 1),(0.666667, 0.217373, 1),(1, 0, 1)]) , 
	    )
	leafdiam.name = "leafdiam"
	inflo_radius = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.160173, 1),(0.393939, 0.151515, 1),(0.735931, 0.0649351, 1),(1, 0.025974, 1)]) , 
	    )
	inflo_radius.name = "inflo_radius"
	inflo_elasticity = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.0278664, 1),(0.341991, 0.034632, 1),(0.675325, 0.04329, 1),(1, 0.252183, 1)]) , 
	    )
	inflo_elasticity.name = "inflo_elasticity"
	radius = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.107326, 1),(0.192635, 0.0975655, 1),(0.457142, 0.000244746, 1),(1, 0.026087, 1)]) , 
	    )
	radius.name = "radius"
	radius_base03 = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.131507, 1),(0.00454138, 0.0251277, 1),(0.578848, 0.00694723, 1),(1, 0.00524218, 1)]) , 
	    )
	radius_base03.name = "radius_base03"
	panel_0 = ({'active': True, 'visible': True, 'name': 'Panel 1'},[('Function',leafsize),('Curve2D',leafpath),('Curve2D',leafsection),('Function',leafdiam),('Function',inflo_radius),('Function',inflo_elasticity),('Function',radius),('Function',radius_base03)])
	parameterset = [panel_0,]
	context["__functions__"] = [('leafsize',leafsize),('leafdiam',leafdiam),('inflo_radius',inflo_radius),('inflo_elasticity',inflo_elasticity),('radius',radius),('radius_base03',radius_base03),]
	context["__curves__"] = [('leafpath',leafpath),('leafsection',leafsection),]
	context["__parameterset__"] = parameterset
	context["leafsize"] = pgl.QuantisedFunction(leafsize)
	context["leafpath"] = leafpath
	context["leafsection"] = leafsection
	context["leafdiam"] = pgl.QuantisedFunction(leafdiam)
	context["inflo_radius"] = pgl.QuantisedFunction(inflo_radius)
	context["inflo_elasticity"] = pgl.QuantisedFunction(inflo_elasticity)
	context["radius"] = pgl.QuantisedFunction(radius)
	context["radius_base03"] = pgl.QuantisedFunction(radius_base03)
