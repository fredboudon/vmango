from openalea.plantgl.all import Text, Scaled, Sphere
from datetime import date, timedelta
from math import floor, ceil, log
from importlib import reload

import probability_tables
reload(probability_tables)

from probability_tables import *
from vplants.mangosim.state import *
from vplants.mangosim.util_date import *
import vplants.mangosim.doralice_mtg.mtg_manipulation  as mm
reload(mm)

variety = 'cogshall'
treenames = mm.get_treenames_of_variety(variety)
#['B10', 'B12', 'B14', 'F2', 'F6']

treeselection = TREE
estimationbase = eVarietyBased if not 'ESTIMATIONBASE' in globals() else ESTIMATIONBASE
if 'ESTIMATIONTYPE' in globals():
  estimationtype = ESTIMATIONTYPE
else:
  estimationtype = (eCompleteGlm if COMPLETE_GLM else eSelectedGlm) if not NULL_MODEL else eNullGlm

treename = treenames[treeselection]
treeid = mm.get_tree_from_name(treename)
Tree_Fruit_Load = mm.load_state(treeid)

if 'WITHINDELAYMETHOD' in globals():
  WithinDelayMethod = WITHINDELAYMETHOD
else:
  WithinDelayMethod = eMonthMultiVariateForWithin # eMonthMultiVariateForWithin, eDeltaMultiVariateForWithin, eDeltaPoissonForWithin


if 'FACTORRESTRICTION' in globals():
  factorrestriction = FACTORRESTRICTION
else:
  factorrestriction = None # eBurstDateRestriction, ePositionARestriction, ePositionAncestorA, eNatureF

use_proba_table_from(treenames[treeselection], estimationbase, estimationtype, factorrestriction)
set_seed(SEED)

first_date = cycle_end(3)
last_date  = cycle_end(5)

daystep = TIMESTEP
total_weeks = week_difference(last_date,first_date)
nbsteps = ceil((last_date -first_date).days/float(daystep))

current_date = first_date
current_cycle = 3

phyllotaxy = 137.5

def Start():
  global current_date
  global current_cycle
  current_date = first_date
  current_cycle = get_cycle(current_date)
  backward()

new_elements = True
def StartEach():
  global new_elements
  useGroup(1 if new_elements else 0)
  new_elements = False


def EndEach():
  global current_date
  global current_cycle
  current_date += timedelta(days = daystep)
  if current_date > last_date:
    current_date = last_date
  current_cycle = get_cycle(current_date)

export_fname = 'simulated_mango_glm.bmtg'
resultmtg = None

def End(lstring,lscene):
  from cPickle import dump,HIGHEST_PROTOCOL
  global resultmtg
  if EXPORT_TO_MTG:
    resultmtg = export_to_mtg(lstring, lscene)
    if SAVE_MTG:
      # write it in the file
      print 'Export result in',repr(export_fname)
      dump(resultmtg,open(export_fname,'wb'),HIGHEST_PROTOCOL)


def export_to_mtg(lstring, lscene):
  from openalea.mtg.io import axialtree2mtg
  parameters = {}
  scales = {}
  # Name of the modules to export
  modules_to_export = ['Tree', 'GU','Inflorescence','Fruit']
  params_to_export = [['treename','method','estimation','loading','variety','within_delay_method','factor_restriction','seed'],['burst_date','cycle'],['bloom_date','cycle'],['inflo_bloom_date','cycle']]
  scales = [1,2,2,2]
  # Convert lstring into mtg
  mtg = axialtree2mtg(lstring,
                      scale = dict(zip(modules_to_export,scales)),
                      
                      scene = None,
                      parameters = dict(zip(modules_to_export,params_to_export)))
  return mtg


module Tree, GU, Inflorescence, Fruit, A

def estimate_radius(nbdescendants):
  return 0.02*pow(nbdescendants, 0.35)

module G
module LeafSets(lradius, age, scale)
module Flower(burst_date,order) # represent flower
module FlowerRepr(day_age,s)


Axiom: 
  nproduce Tree(ParameterSet(treename=treename, method=EstimationBaseName[estimationbase], estimation='CompleteGLM' if estimationtype == eCompleteGlm else 'SelectedGLM',loading='C' if Tree_Fruit_Load else 'NC',variety=variety, seed=SEED, within_delay_method = WithinDelayMethodName[WithinDelayMethod],factor_restriction=factorrestriction))
  #  produce A(ParameterSet(burst_date=first_date,position=eApical,position_ancestor=None,nature_ancestor=None))
  l = Lsystem('../doralice_mtg/mango_mtg_replay.lpy',{'TREE':TREE})
  base = l.derive(1)
  for m in base:
    if m.name == 'A':
      if m[0].burst_date.month < 6:
        d = m[0].burst_date
        m[0].burst_date = date(year=d.year,month = 6,day=d.day)
  nsproduce(base)

derivation length: int(nbsteps)
ignore: / &
production:

group 1:
GU(p) >> x([ GU(pl) ]) GU(pa):
  p.nbdescendants = sum([pli.nbdescendants for pli in pl])+pa.nbdescendants+1
  p.radius = estimate_radius(p.nbdescendants)
  produce GU(p)

GU(p) >> x([ GU(pl) ]) :
  p.nbdescendants = sum([pli.nbdescendants for pli in pl])+1
  p.radius = estimate_radius(p.nbdescendants)
  produce GU(p)


group 0:
decomposition:
maximum depth: 100
A( p ):
  if  p.burst_date <= current_date :
    global new_elements
    new_elements = True
    dev = UnitDev(Burst_Date=p.burst_date, 
                  Position_A=p.position,
                  Position_Ancestor_A=p.position_ancestor,
                  Nature_Ancestor_F = eVegetative if p.nature_ancestor == eVegetative else eFlowering,
                  Tree_Fruit_Load=Tree_Fruit_Load,
                  WithinDelayMethod = WithinDelayMethod)
    apical_child, nb_lat_children, nb_inflorescences, nb_fruits, date_children_burst, date_inflo_bloom = dev.process()
    
    p = p.copy()
    p.set(nature = eFlowering if nb_inflorescences > 0 else eVegetative,
          nbdescendants = 1, radius = estimate_radius(1),
          cycle = current_cycle)
    nproduce /(phyllotaxy) GU(p)
    
    nb_lat_inflo = nb_inflorescences if apical_child else max(0,nb_inflorescences-1)
    nb_lat_elements = nb_lat_children + nb_lat_inflo
    nb_fruiting_lat_inflo = min(nb_lat_inflo, max(0, nb_fruits - int(not apical_child)))
    if nb_lat_elements > 0:
      anglebetweenchildren = 360./nb_lat_elements
    if not date_children_burst is None:
      date_children_burst = date(year=date_children_burst[0], month=date_children_burst[1], day=15)
      if date_children_burst > cycle_end(5):
        import warnings
        warnings.warn('Invalid date of burst %s (after last date %s) of children with parent borned in %s (in cycle %i)' %(date_children_burst, cycle_end(5),p.burst_date,current_cycle))
      cyclechange = (get_cycle(date_children_burst) != get_cycle(p.burst_date))
      baseparameter = ParameterSet(burst_date=date_children_burst, 
                                 nature_ancestor=p.nature_ancestor if not cyclechange else p.nature, 
                                 position_ancestor=p.position_ancestor if not cyclechange else p.position)
      if nb_lat_children > 0:
        latparam = baseparameter.copy()
        latparam.set(position = eLateral)
        for i in xrange(nb_lat_children):
            nproduce /(anglebetweenchildren) [&(60) A(latparam.copy()) ]
      
    if nb_inflorescences > 0:
      for i in xrange(nb_lat_inflo):
          nproduce /(anglebetweenchildren) [&(60) Inflorescence(ParameterSet(bloom_date=date_inflo_bloom, cycle =  get_cycle(p.burst_date), nb_fruits = (1 if i < nb_fruiting_lat_inflo else 0))) ]
    
    if apical_child:
        p = baseparameter
        p.set(position = eApical)
        nproduce A(p)
    elif nb_inflorescences > 0:
      nproduce Inflorescence(ParameterSet(bloom_date=date_inflo_bloom, cycle =  get_cycle(p.burst_date), nb_fruits = nb_fruits - nb_fruiting_lat_inflo))
    

Inflorescence(param):
  if not param.hasattr('produced') and param.nb_fruits > 0 and (param.bloom_date - current_date).days >=  60:
    param.produced = True
    nproduce Inflorescence(param)
    if FRUITING:
      if param.nb_fruits == 1 :
        nproduce [Fruit(ParameterSet(inflo_bloom_date= param.bloom_date, cycle = param.cycle))]
      else : 
        anglebetweenfruits = 120. / (param.nb_fruits -1)
        angles = [90 - i * anglebetweenfruits for i in xrange(param.nb_fruits)]
        for ang in angles:
          nproduce [+(ang) Fruit(ParameterSet(inflo_bloom_date= param.bloom_date, cycle = param.cycle))]


interpretation:
maximum depth:5

# Setup  tropism and legend
# Note that the 2D legend cause a crash of lpy when recording the animation
G : 
  if TIMEBAR:
    ar = False
    envsize = 0.8
    nproduce [ @2D ,(5) @M(-0.85,-0.85) 
    nproduce Label('Tree : '+treename+'. Date: '+str(current_date.year)+'-'+str(current_date.month).zfill(2)+'-'+str(current_date.day).zfill(2)+'. Cycle: '+str(get_cycle(current_date)),14)
    clength = (current_date - first_date).days/float((last_date - first_date).days)
    nproduce ,(4) @M(-0.91,-0.9) -(90) _(0.04) F(0.01)
    if clength > 0:
      nproduce ,(2) @M(-0.9,-0.9) _(0.03) F(clength*envsize)
      nproduce ,(3) @M(-0.9+clength*envsize,-0.9) _(0.04) F(0.01)  
    if clength < 1:
      nproduce ,(4) @M(-0.9+envsize,-0.9) _(0.04) F(0.01)
      nproduce ,(5) @M(-0.9,-0.9) _(0.02) F(envsize)
    nproduce ]
  produce @Tp(0,0,1) @Ts(Elasticity)


#A(p) --> ,(3) f(0.1) @O(0.1)

GU(p):
  bdate = p.get('burst_date')
  is_base = (bdate is None)
  if not is_base:
    week_age = week_difference(current_date,bdate)
    produce ,(2) _(p.radius) LeafSets(p.radius, week_age, 1)
  else:
    produce ,(7) _(p.radius) nF(p.length, p.length/10.)

LeafSets(lradius, age, scale):
  ds = scale / 10.
  if LEAFY and age < 56 :
    phy = 137.5
    nproduce @Gc  F(ds) Leaf(0,lradius, leafsize(0.1), scale ) 
    nbleaf, dl = (ceil((scale-ds)*5),2*ds)
    for i in xrange(1,int(nbleaf)):
      nproduce nF(dl,ds) Leaf(phy*i,lradius, leafsize(0.1+0.1*i ), scale )
    nproduce F(ds) @Ge
    for i in xrange(1,4):
      nproduce Leaf(phy*i,lradius, leafsize(1),scale )
  else:
    produce  @Gc nF(1,0.1) @Ge

Leaf(angle, radius, length, scale ):
  produce [ /(angle) &(90)  f(radius) @Ge @Gc @v &(10) Sweep(leafpath,leafsection,length*scale,length*scale/10,scale,leafdiam)]

Flower(date_inflo,order) :
  day_age = (current_date - date_inflo).days
  if day_age < 60:
    produce FlowerRepr(day_age, date_inflo.year + date_inflo.month + date_inflo.day)

Inflorescence(p) :
  bloom_date = p.bloom_date if p.hasattr('bloom_date') else (p.bloom_dates[0] if p.bloom_dates else first_date)
  day_age = (current_date - bloom_date).days
  if day_age < 60:
    produce FlowerRepr(day_age, bloom_date.year + bloom_date.month + bloom_date.day)

FlowerRepr(day_age,s) :
  growth_duration = 21.
  flower_growth_duration = 21.
  scale = min(1,day_age/growth_duration)
  if LEAFY:
    import random as rd
    rdstate = rd.getstate()
    rd.seed(s)
    flower_radius = 0 if day_age < growth_duration else 0.04*min(1,(day_age-flower_growth_duration)/flower_growth_duration)
    nproduce [
    if day_age > growth_duration :  nproduce @Tp(0,0,-1) @Ts(inflo_elasticity(min(1,(day_age-growth_duration)/40.))) 
    nproduce ,(3) _(0.01) F(0.1)
    nbflower = 4
    nbelem = int(floor(10 * scale))
    for i in xrange(10-nbelem,10):
       nproduce    F(0.1) [ /(rd.randint(0,180))
       for j in xrange(nbflower):
           nproduce [ /(j*90)  &(rd.randint(70,110)) F(inflo_radius(i*0.1)) 
           if flower_radius > 0: nproduce ,(4) @O(flower_radius) 
           nproduce ]
       nproduce ]
    nproduce ,(3) F(0.1)
    if flower_radius > 0: nproduce ,(4) @O(0.04) 
    nproduce ]
    rd.setstate(rdstate)
  else:
    scale = 0.3
    produce ,(4) _(inflo_radius(0))F(scale,inflo_radius(1))

Fruit(p):
  nproduce F(0.3) ,(6) @g(Scaled(0.2, 0.2, 0.4, Sphere(1)))

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_7 = pgl.Material("Color_7" , ambient = (57,65,12) , diffuse = 1.66154 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	scalars = [('Simulation', 'Category'), ('TREE', 'Integer', 4, 0, 4), ('TIMESTEP', 'Integer', 30, 1, 750), ('EXPORT_TO_MTG', 'Bool', False), ('SAVE_MTG', 'Bool', False), ('FRUITING', 'Bool', False), ('Geometry', 'Category'), ('TIMEBAR', 'Bool', True), ('LEAFY', 'Bool', True), ('Elasticity', 'Float', 0.03, 0.0, 1.0, 2), ('GLM', 'Category'), ('COMPLETE_GLM', 'Bool', False), ('SEED', 'Integer', 2, 1, 100000), ('NULL_MODEL', 'Bool', False)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
	import openalea.plantgl.all as pgl
	leafsize = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.431282, 1),(0.324129, 0.436757, 1),(0.408886, 0.416427, 1),(0.412274, 0.708684, 1),(0.844357, 0.703533, 1),(1, 0.246499, 1)]) , 
	    )
	leafsize.name = "leafsize"
	import openalea.plantgl.all as pgl
	leafsection = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.201299, 0.231602, 1),(-0.253247, 0.181818, 1),(-0.166667, 0, 1),(-0.0196652, -0.0165724, 1),(0.00408221, 0.0220172, 1),(0.0454545, -0.0151515, 1),(0.214286, -0.012987, 1),(0.383117, 0.164502, 1),(0.344156, 0.24026, 1)]) , 
	    )
	leafsection.name = "leafsection"
	leafpath = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.5, 0, 1),(-0.145022, -0.0735931, 1),(0.0844156, -0.212121, 1),(0.123377, -0.497835, 1)]) , 
	    )
	leafpath.name = "leafpath"
	inflo_elasticity = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.0278664, 1),(0.341991, 0.034632, 1),(0.675325, 0.04329, 1),(1, 0.252183, 1)]) , 
	    )
	inflo_elasticity.name = "inflo_elasticity"
	leafdiam = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.017316, 1),(0.167909, 0.309417, 1),(0.666667, 0.217373, 1),(1, 0, 1)]) , 
	    )
	leafdiam.name = "leafdiam"
	inflo_radius = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.160173, 1),(0.393939, 0.151515, 1),(0.735931, 0.0649351, 1),(1, 0.025974, 1)]) , 
	    )
	inflo_radius.name = "inflo_radius"
	radius_base03 = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.131507, 1),(0.00454138, 0.0251277, 1),(0.578848, 0.00694723, 1),(1, 0.00524218, 1)]) , 
	    )
	radius_base03.name = "radius_base03"
	radius = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.107326, 1),(0.192635, 0.0975655, 1),(0.457142, 0.000244746, 1),(1, 0.026087, 1)]) , 
	    )
	radius.name = "radius"
	panel_0 = ({'active': True, 'visible': True, 'name': 'Panel 2'},[('Function',leafsize),('Curve2D',leafsection),('Curve2D',leafpath),('Function',inflo_elasticity),('Function',leafdiam),('Function',inflo_radius),('Function',radius_base03),('Function',radius)])
	parameterset = [panel_0,]
	context["__functions__"] = [('leafsize',leafsize),('inflo_elasticity',inflo_elasticity),('leafdiam',leafdiam),('inflo_radius',inflo_radius),('radius_base03',radius_base03),('radius',radius),]
	context["__curves__"] = [('leafsection',leafsection),('leafpath',leafpath),]
	context["__parameterset__"] = parameterset
	context["leafsize"] = pgl.QuantisedFunction(leafsize)
	context["leafsection"] = leafsection
	context["leafpath"] = leafpath
	context["inflo_elasticity"] = pgl.QuantisedFunction(inflo_elasticity)
	context["leafdiam"] = pgl.QuantisedFunction(leafdiam)
	context["inflo_radius"] = pgl.QuantisedFunction(inflo_radius)
	context["radius_base03"] = pgl.QuantisedFunction(radius_base03)
	context["radius"] = pgl.QuantisedFunction(radius)
