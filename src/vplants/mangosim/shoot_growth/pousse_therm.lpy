from datetime import *
from openalea.plantgl.all import *
from math import *
from random import *
from math import degrees

# Choix des parametres
current_date = datetime(2003,7,1)
B=1                                     # parametre de pente de la courbe de croissance
t_ip=5
temperature=[randint(25,30) for i in xrange(NbOfDays+1)]
base_temperature=13

# Initialisation des variables
totlength = []                          # vecteur des longueurs de l'UC
phyllotaxy = 137.5
final_diamI = 0.1
temp_index=0

# Choix du pas de temps : 1/24 = une heure
if DAILY:
  pdt = 1
else:
  pdt=1/24.                              
delta_date = timedelta(hours=24*pdt)

# Definition stades phenologiques
pheno_change_temp=[0,20,40,60,80,120,300]
pheno_color=[7,8,9,10,11,12,13]
Nb_stades_pheno=7


# Fct qui renvoit le stade pheno et l'avancement (entre 0 et 1) dans ce stade
def normalized_pheno_stage(cumtemp,pheno_stage = None):
  # Si le stade pheno n'est pas connu on le cherche
  if pheno_stage == None:
    if cumtemp > pheno_change_temp[-1]:
      pheno_stage=Nb_stades_pheno
    else:
      i=Nb_stades_pheno-1
      while i!=0:
        if cumtemp > pheno_change_temp[i]:
          pheno_stage=i+1
          i=0
        else:
          i=i-1     
      if pheno_stage==None: pheno_stage=1
  # Sinon on verifie si on passe au stade suivant
  if pheno_stage == (Nb_stades_pheno-1):
    pheno_advancement =0
  else:
    entry_pheno_temp=pheno_change_temp[pheno_stage]
    exit_pheno_temp=pheno_change_temp[pheno_stage+1]
    if cumtemp > exit_pheno_temp:
      pheno_advancement =0
      pheno_stage+=1
    else:
      pheno_advancement =(cumtemp-entry_pheno_temp)/(exit_pheno_temp-entry_pheno_temp)
  return [pheno_advancement, pheno_stage]


def retrieveCurves():
  # Determine the set of curve representing axis at different time. 
  # Look for object in global namespace name axisX 
  curves = [(n,v) for n,v in globals().items() if 'axis' in n and type(v) == BezierCurve2D ]
  
  # sort curves according to their names
  for n,v in curves: v.name = n
  curves = [v for n,v in curves]
  curves.sort(lambda x,y : cmp(x.name,y.name))
  return curves

def ProfileInterpolation(curves,knotlist = None,degree = 3):
    nbcurves = len(curves)
    if knotlist is None: knotlist = [i/float(nbcurves-1) for i in xrange(nbcurves)]
    k = [knotlist[0] for i in xrange(degree-1)]+knotlist+[knotlist[-1] for i in xrange(degree-1)]
    pts = [[(i.x,i.y,0,1) for i in c.ctrlPointList] for c in curves]
    ppts = Point4Matrix(pts)
    p = NurbsPatch(ctrlPointList=ppts,udegree=degree,vdegree=3)
    def getSectionAt(t): 
      section = p.getIsoUSectionAt(t)
      return NurbsCurve2D([(i.x,i.y,i.w) for i in section.ctrlPointList], section.knotList,section.degree)
    p.getAt = getSectionAt
    return p

curves = retrieveCurves()
axisfunc = ProfileInterpolation(curves,[0,0.1,0.5,0.8,0.95,1])

def Start():
  global current_date
  current_date = datetime(2003,7,1)
  global totlength
  totlength = [(0,0)]

def StartEach():
  global temperature
  # On verifie si on passe au jour suivant
  if ((current_date.month!=(current_date+delta_date).month) or (current_date.day!=(current_date+delta_date).day)):
    global temp_index
    temp_index+=1
  global current_date
  current_date += delta_date
  global length_inter
  length_inter=0.0001   #initialisation a 0
  global age_inter
  age_inter=0.0001
  global delta_temperature
  delta_temperature=max(0,temperature[temp_index]-base_temperature)
  
  
def GrowthCurve(T,FinalSize):
  y=FinalSize/(1+exp(-(T-t_ip)/B))
  return(y)
  

def plotCurve(data, xextend = None, yextend = None, pos = (0.1,-0.8), dim = (0.8,0.8), xtick = None, ytick = None ):
  if len(data) > 1:
    if xextend:
      minx, maxx = xextend
    else :
      minx = floor(min([x for x,y in data]))
      maxx = ceil(max([x for x,y in data]))
    if yextend:
      miny, maxy = yextend
    else :
      miny = floor(min([y for x,y in data]))
      maxy = ceil(max([y for x,y in data]))
    xext = maxx - minx
    yext = maxy - miny
    x2Dlength, y2Dlength = dim
    projx = lambda x: (x2Dlength*(x-minx)/xext)
    projy = lambda y: (y2Dlength*(y-miny)/yext)
    if xtick is None:
      xtick = yext*0.1
    if ytick is None:
      ytick = xext*0.1
    
    data = [(projx(x),projy(y)) for x,y in data]
    ticklength = 0.02
    
    nproduce [ @2D ,(3) @M(pos[0],pos[1]) @R @g(Polyline2D(data,width=2))
    if miny <= 0 <= maxy:
      nproduce ,(5) @g(Polyline2D([(projx(minx),projy(0)),(projx(maxx),projy(0))]))
      cxtick = minx + xtick
      while cxtick < maxx:
        nproduce ,(5) @g(Polyline2D([(projx(cxtick),projy(-ticklength)),(projx(cxtick),projy(ticklength))]))
        cxtick += xtick
    if minx <= 0 <= maxx:
      nproduce ,(2) @g(Polyline2D([(projx(0),projy(miny)),(projx(0),projy(maxy))]))
      cytick = miny + ytick
      while cytick < maxy:
        nproduce ,(2) @g(Polyline2D([(projx(-ticklength),projy(cytick)),(projx(ticklength),projy(cytick))]))
        cytick += ytick
    nproduce ]




module Bud(burstdate) 
module Internode(length, age, final_size, diam, pheno_stage), Leaf(position, length, age, final_size, pheno_stage)
module Env

Axiom: Env Bud(current_date+timedelta(days=2))

derivation length: ceil(NbOfDays/pdt)
production:

Bud(burst):
  if (burst == current_date) :
    final_size_internode=min(max(6,gauss(16.67,4.56)),25)
    final_size_leaf=min(max(5,gauss(15.23,6.15)),34)
    NbInternode=int(max(ceil(0.6*final_size_internode)+randint(-1,1),1))
    nproduce C(0,final_size_internode)
    for i in xrange(NbInternode-1):
      nproduce Internode(ParameterSet(length=0.01,age=0,final_size=final_size_internode/NbInternode,diam=0.01,pheno_stage=0,cumsum_temp=0,pheno_advct=0)) /(phyllotaxy) [ &(0) Leaf(ParameterSet(position=i/float(NbInternode),size=0.1,age=0,final_size=final_size_leaf)) ]
    nproduce Internode(ParameterSet(length=0.01,age=0,final_size=final_size_internode/NbInternode,diam=0.01,pheno_stage=0,cumsum_temp=0,pheno_advct=0)) /(phyllotaxy) [ &(0) Leaf(ParameterSet(position=i/float(NbInternode),size=0.1,age=0,final_size=final_size_leaf/2.)) ]
    nproduce C

Internode(param):
  new_param=param.copy()
  new_param.age += pdt
  global delta_temperature
  new_param.cumsum_temp+= delta_temperature*pdt
  [pheno_advct_stage,new_param.pheno_stage]=normalized_pheno_stage(new_param.cumsum_temp,new_param.pheno_stage)
  new_param.pheno_advct=pheno_advct_stage
  l = GrowthCurve(new_param.age,new_param.final_size)
  d = GrowthCurve(new_param.age,final_diamI)
  new_param.length=l
  new_param.diam=d
  global length_inter
  length_inter +=l
  global age_inter
  age_inter=new_param.age
  produce Internode(new_param)

Leaf(param):
  new_param=param.copy()
  new_param.age += pdt
  new_param.size = GrowthCurve(new_param.age,new_param.final_size)
  produce Leaf(new_param)  

interpretation:
C:
  global totlength
  if age_inter <=10:
    totlength.append((age_inter,length_inter))
  plotCurve(totlength)

Internode(param) --> F(param.length,param.diam) 

consider: Internode

Internode(paramI) < Leaf(paramL) :
  
  produce ,(2) [ /(137.5) &(90) f(paramI.diam) ^(90) &(ang( (paramI.pheno_stage+paramI.pheno_advct)/6. )*100) f(0.0) ,(pheno_color[paramI.pheno_stage])   @Gc _(leafdiam(paramI.diam)) @G Sweep(axisfunc.getAt((paramI.pheno_stage+paramI.pheno_advct)/6.),leafsection, paramL.size, paramL.size/10., paramL.size*leafwidth(min((paramL.age+1)/20.,1)), leafdiam) ]  

Bud(burstdate) --> ,(3) @O(0.11)

Env --> @g(ScreenProjected(Translated(-0.5,-0.7,0,Text(str(current_date)))))

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_7 = pgl.Material("Color_7" , ambient = (62,125,20) , diffuse = 2.04 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (78,102,23) , diffuse = 1.50437 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (70,113,21) , diffuse = 1.77218 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (95,79,27) , diffuse = 0.968421 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_11 = pgl.Material("Color_11" , ambient = (121,46,33) , diffuse = 0.165289 , )
	Color_11.name = "Color_11"
	context.turtle.setMaterial(11,Color_11)
	Color_12 = pgl.Material("Color_12" , ambient = (60,60,15) , diffuse = 3 , )
	Color_12.name = "Color_12"
	context.turtle.setMaterial(12,Color_12)
	Color_13 = pgl.Material("Color_13" , ambient = (30,60,10) , diffuse = 1.68333 , )
	Color_13.name = "Color_13"
	context.turtle.setMaterial(13,Color_13)
	context.animation_timestep = 0.001
	scalars = [('DAILY', 'Bool', False), ('NbOfDays', 'Integer', 40, 1, 100)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] is "Category" : context[s[0]] = s[2]
	import openalea.plantgl.all as pgl
	leafdiam = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.0359806, 1),(0.146454, 0.203327, 1),(0.34022, 0.310394, 1),(1, 0.0239871, 1)]) , 
	    )
	leafdiam.name = "leafdiam"
	leafwidth = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0, 1),(0.281668, -0.00351979, 1),(0.281668, 1.00209, 1),(1, 1, 1)]) , 
	    )
	leafwidth.name = "leafwidth"
	import openalea.plantgl.all as pgl
	leafsection = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.499725, 0.200786, 1),(-0.525007, 0.143183, 1),(-0.198373, -0.0924227, 1),(-0.00298323, 0.188761, 1),(0.0897461, -0.106293, 1),(0.555704, 0.0979703, 1),(0.491547, 0.144516, 1)]) , 
	    )
	leafsection.name = "leafsection"
	leafpath = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.416733, 0.0128104, 1),(0.2343, -0.076231, 1),(0.507411, -0.330906, 1),(0.662132, -0.814102, 1)]) , 
	    )
	leafpath.name = "leafpath"
	axis1 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.5, 0, 1),(-0.166667, 0, 1),(0.214286, 0.00865801, 1),(0.45671, 0.138528, 1)]) , 
	    )
	axis1.name = "axis1"
	axis2 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.5, 0, 1),(-0.166667, 0, 1),(0.209957, -0.017316, 1),(0.491342, -0.0952381, 1)]) , 
	    )
	axis2.name = "axis2"
	axis3 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.5, 0, 1),(-0.166667, 0, 1),(0.166667, 0, 1),(0.5, 0, 1)]) , 
	    )
	axis3.name = "axis3"
	axis4 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.5, 0, 1),(-0.158009, -0.047619, 1),(0.166667, 0.004329, 1),(0.443723, -0.393939, 1)]) , 
	    )
	axis4.name = "axis4"
	axis5 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.416733, 0.0128104, 1),(0.2343, -0.076231, 1),(0.507411, -0.330906, 1),(0.662132, -0.814102, 1)]) , 
	    )
	axis5.name = "axis5"
	ang = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0, 1),(0.286308, 0.522427, 1),(0.630023, 1.16301, 1),(0.7981, 1.52128, 1),(0.908345, 0.885562, 1),(1, 0.51116, 1)]) , 
	    )
	ang.name = "ang"
	panel_0 = ({'active': True, 'visible': True, 'name': 'Panel 1'},[('Function',leafdiam),('Function',leafwidth),('Curve2D',leafsection),('Curve2D',leafpath),('Curve2D',axis1),('Curve2D',axis2),('Curve2D',axis3),('Curve2D',axis4),('Curve2D',axis5),('Function',ang)])
	parameterset = [panel_0,]
	context["__functions__"] = [('leafdiam',leafdiam),('leafwidth',leafwidth),('ang',ang),]
	context["__curves__"] = [('leafsection',leafsection),('leafpath',leafpath),('axis1',axis1),('axis2',axis2),('axis3',axis3),('axis4',axis4),('axis5',axis5),]
	context["__parameterset__"] = parameterset
	context["leafdiam"] = pgl.QuantisedFunction(leafdiam)
	context["leafwidth"] = pgl.QuantisedFunction(leafwidth)
	context["leafsection"] = leafsection
	context["leafpath"] = leafpath
	context["axis1"] = axis1
	context["axis2"] = axis2
	context["axis3"] = axis3
	context["axis4"] = axis4
	context["axis5"] = axis5
	context["ang"] = pgl.QuantisedFunction(ang)
