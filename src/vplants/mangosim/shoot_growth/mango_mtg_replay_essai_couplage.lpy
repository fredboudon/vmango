from openalea.plantgl.all import * #Text
from datetime import *# date, timedelta, datetime
from math import *#floor, ceil, log, exp, degrees
from random import *
from pandas import DataFrame, read_csv

from vplants.mangosim.state import *
from vplants.mangosim.util_date import *
import vplants.mangosim.doralice_mtg.mtg_manipulation  as mm
reload(mm)

from vplants.mangosim.tools import load_obj
#mtg = mm.get_mtg()
mtg = load_obj("simulated_mango_glm.bmtg",'../glm_simulation')
mm.setMtgStyle(mm.eSimulatedMtg)

treenames = mm.get_treenames_of_variety(mtg)
#['B10', 'B12', 'B14', 'F2', 'F6']
treeselection = TREE
treename = treenames[treeselection]

treeid = mm.get_tree_from_name(mtg,treename)
first_uc = mm.get_first_gu(mtg,treeid)

height_max_3 = max([mtg.Height(gu) for gu in mm.get_terminal_gus_of_tree_at_cycle(mtg,treeid,3)])
height_max = max([mtg.Height(gu) for gu in mm.get_terminal_gus_of_tree_at_cycle(mtg,treeid,5)])

first_date = cycle_end(3)-timedelta(days=1)
last_date  = cycle_end(5)

#daystep = 1
total_weeks = week_difference(last_date,first_date)
nbsteps = ceil((last_date -first_date).days/float(daystep))
current_date = first_date
current_cycle = 3


global NbOfDays
NbOfDays=3000 #len(df['tempMoy'])                  
temperature=[45 for i in xrange(NbOfDays+1)]

# Initialisation des variables
mean_tip_GU=79.40
sd_tip_GU=10.75
t_ip_Leaf=182.04/2.                           # point d'inflexion de la courbe de croissance pour les feuilles
t_ip_Inflo=346.03/2.                          # point d'inflexion de la courbe de croissance pour les inflorescences

base_temperature_GU=9.2                     # Temperature de base des UCs
base_temperature_Leaf=10.73                 # Temperature de base des feuilles
base_temperature_Inflo=11.12                # Temperature de base des inflorescences

totlength = []                              # vecteur des longueurs de l'UC
infoUC= []                                  # vecteur permettantla recoltes d'informations lors de la croissance
infoUC.append(('Days', 'TTS', 'Length','Pheno_stage'))
phyllotaxy = 144+randint(-2,2)              # angle correspondant a la phyllotaxie du manguier
final_diamI = 0.2                           # diametre final des UCs
temp_index=0                                # index permettant de parcourir les temperatures jour par jour
point=[]


# Choix d'un pas de temps horaire ou journalier : 1/24 = une heure
#if DAILY:
#  pdt = 1
#else:
#  pdt=1/24.   
pdt=daystep                       
delta_date = timedelta(hours=24*pdt)

# Définition des stades phenologiques
pheno_base_temp_GU=[13.37766,13.37766,13.37766,9.784431,0]    # stades DEF_G_H
pheno_change_temp_GU=[38.50,47.61+38.50,47.39+47.61+38.50,316.376+47.39+47.61+38.50,999+316.376+47.39+47.61+38.50]       # temperatures auxquelles ont lieu les changements de stade UC
pheno_color=[7,10,11,14,13,13]                       # couleurs pour chaque stade
pheno_angle=[0,90,165,60,60,60]                     # angle entre la feuille et l'UC pour chaque stade
Nb_stades_pheno=len(pheno_change_temp_GU)              # nombre de stades phenologiques

pheno_base_temp_Inflo=[11.10,5.38,8.67,15.11,0]                # températures de base pour chaque stade phéno
pheno_change_temp_Inflo=[70.56,172.35+70.56,133.32+172.35+70.56,230.42+133.32+172.35+70.56,999+230.42+133.32+172.35+70.56]       # temperatures auxquelles ont lieu les changements de stade Inflo

#if Vegetative==False:
pheno_color_inflo=[15,16,16,16,16,16]                                    # couleurs pour chaque stade (inflorescences)
pheno_color_flower=[13,2,7,12,4,4]

Nb_stades_pheno=len(pheno_change_temp_GU)              # nombre de stades phenologiques

# Parametres des distributions gaussiennes
# Longueur des UCs (en position : apicale d'UC mere apicale, apicale d'UC mere laterale, laterale)
GU_length_apic_apic_mean=18.14
GU_length_apic_apic_sd=4.14

GU_length_apic_lat_mean=13.79
GU_length_apic_lat_sd=4.03

GU_length_lat_mean=12.59
GU_length_lat_sd=3.38

# Longueur des feuilles (en position apicale, laterale)
Leaf_length_apic_mean=17.06 
Leaf_length_apic_sd=2.7

Leaf_length_lat_mean=14.87
Leaf_length_lat_sd=2.7

# Longueur des inflorescences
Inflo_length_mean=23.15833
Inflo_length_sd=6.767254



def Start():
  global current_date
  global current_cycle
  current_date = first_date
  current_cycle = get_cycle(current_date)
  backward()

def StartEach():
  # On verifie si on passe au jour suivant et on avance d'un pas de temps
  global current_date
  if ((current_date.month!=(current_date+delta_date).month) or (current_date.day!=(current_date+delta_date).day)):
    global temp_index
    temp_index+=1
  current_date += delta_date
  
  # longueur et age de l'UC pour tracer le graphique
  global length_inter
  length_inter=0.0001   #initialisation a 0
  global age_inter
  age_inter=0.0001
  global cumsum_inter
  cumsum_inter=0.0001
  global pheno_inter
  pheno_inter=0
  
  # Calcul de la temperature a ajouter a la somme en temps thermique (croissance)
  global temperature
  global delta_temperature_GU      
  delta_temperature_GU=max(0,temperature[temp_index]-base_temperature_GU)        # pour les UCs
  global delta_temperature_Leaf 
  delta_temperature_Leaf=max(0,temperature[temp_index]-base_temperature_Leaf)    # pour les feuilles
  global delta_temperature_Inflo 
  delta_temperature_Inflo=max(0,temperature[temp_index]-base_temperature_Inflo)    # pour les inflorescences



def EndEach():
  global current_date
  global current_cycle
  #current_date += timedelta(days = daystep)
  current_cycle = get_cycle(current_date)

# Fct qui renvoit le stade pheno et l'avancement (entre 0 et 1) dans ce stade
def normalized_pheno_stage(cumtemp,type):
  if type=="GU":
    pheno_change_temp=pheno_change_temp_GU
  else:
    pheno_change_temp=pheno_change_temp_Inflo
  # On cherche le stade pheno
  pheno_stage=None
  if cumtemp > pheno_change_temp[-2]:     # on teste si la somme des temp cumulee est superieure a la derniere temp de chgt de stade
      pheno_stage=Nb_stades_pheno-1         # si oui on est dans le dernier stade
  else:
      i=Nb_stades_pheno-3                   # si non, on boucle jusqu'a etre inferieur a une temp de chgt de stade
      while i!=-1:
        if cumtemp > pheno_change_temp[i]:
          pheno_stage=i+1
          i=-1
        else:
          i=i-1     
  if pheno_stage==None: pheno_stage=0
  if pheno_stage == (Nb_stades_pheno-1):     # si on est au dernier stade on n'avance plus
    pheno_advancement =0                     
  else:                                      # si non, on calcul l'avancement dans le stade
    if pheno_stage==0: entry_pheno_temp=0
    else:
      entry_pheno_temp=pheno_change_temp[pheno_stage-1]
    exit_pheno_temp=pheno_change_temp[pheno_stage]
    cumtemp=cumtemp-entry_pheno_temp 
    pheno_advancement =cumtemp/(exit_pheno_temp-entry_pheno_temp)
  return [pheno_advancement, pheno_stage]




# Fonction qui calcule la taille de l'organe (feuille ou UC) 
# en fonction de sa taille finale et de ses tem cumulees 
def GrowthCurve(T,FinalSize_organ,type,FinalSize,t_ip):
  if type=="GU":                               # Pour les UCs
    maxER=0.0111513*FinalSize                  # relation entre taille finale et vitesse maximale de croissance pour les UCs
    B=FinalSize/(4*maxER)   
    y=FinalSize_organ/(1+exp(-(T-t_ip)/B))  # equation de la sigmoide

  elif type == "Leaf":                                        # Pour les feuilles
    maxER=-0.0188725+0.0147985*FinalSize
    B=FinalSize/(4*maxER)
    y=FinalSize_organ/(1+exp(-(T-t_ip_Leaf)/B))
    
  else:                                        # Pour les inflorescences
    maxER=0.0049161*FinalSize 
    B=FinalSize/(4*maxER)
    y=FinalSize_organ/(1+exp(-(T-t_ip_Inflo)/B))
  return(y)
  
def retrieveCurves():
  # Determine the set of curve representing axis at different time. 
  # Look for object in global namespace name axisX 
  curves = [(n,v) for n,v in globals().items() if 'axis' in n and type(v) == BezierCurve2D ]
  
  # sort curves according to their names
  for n,v in curves: v.name = n
  curves = [v for n,v in curves]
  curves.sort(lambda x,y : cmp(x.name,y.name))
  return curves

# Fonction qui permet d'interpoler des courbes afin de faire evoluer une forme (ici cellede la feuille) au cours du temps
def ProfileInterpolation(curves,knotlist = None,degree = 3):
    nbcurves = len(curves)
    if knotlist is None: knotlist = [i/float(nbcurves-1) for i in xrange(nbcurves)]
    k = [knotlist[0] for i in xrange(degree-1)]+knotlist+[knotlist[-1] for i in xrange(degree-1)]
    pts = [[(i.x,i.y,0,1) for i in c.ctrlPointList] for c in curves]
    ppts = Point4Matrix(pts)
    p = NurbsPatch(ctrlPointList=ppts,udegree=degree,vdegree=3)
    def getSectionAt(t): 
      section = p.getIsoUSectionAt(t)
      return NurbsCurve2D([(i.x,i.y,i.w) for i in section.ctrlPointList], section.knotList,section.degree)
    p.getAt = getSectionAt
    return p

curves = retrieveCurves()
axisfunc = ProfileInterpolation(curves,[0,0.1,0.5,0.6,0.7,0.8])


def estimate_radius(nbdescendants):
  return 0.02*pow(nbdescendants, 0.35)

# estimate nb of descendants for the pipe model
@mm.use_global_mtg
def estimate_nb_descendants(mtg, first_uc):
  from openalea.mtg.traversal import post_order2
  nbdescendants = {}
  for gu in post_order2(mtg, first_uc):
    if mm.get_unit_cycle(mtg,gu) == 3:
      nbdescendants[gu] = sum([nbdescendants[cgu] for cgu in mm.vegetative_children_at_cycle(mtg,gu,3)])+1
  return nbdescendants

nbdescendants = estimate_nb_descendants(mtg,first_uc)


module GU, Inflorescence, A, B, GUEnd, Internode, Leaf,Bourgeon_Inflo

def generate_elements(current, burst_date = None, length=None, nbdescendants = 1):
    # On effectue les tirages pour la simulation
    if mm.get_nature_gu(mtg, current)==1: #On teste si on est en presence d'une UC vegetative
      cum=delta_temperature_GU*pdt
      cumL=delta_temperature_Leaf*pdt
      # si oui on teste si l'UC en croissance est apicale
      if mm.get_parent(mtg, current)==None: 
        position_gu=1
        racine=1
      else :
        position_gu=mm.get_position_gu(mtg, current)
        racine=0
      if position_gu==1:
        hypo=gauss(2.63,1.72)  #On tire une longueur d'espace pre-feuille
        # On teste le position de l'UC mere
        if racine==1 : position_gu_ancetre=1
        else:
          if mm.get_parent(mtg,mm.get_parent(mtg, current))==None: position_gu_ancetre=1
          else: position_gu_ancetre=mm.get_position_gu(mtg,mm.get_parent(mtg, current))
        if (position_gu_ancetre==1):
          final_size=gauss(GU_length_apic_apic_mean,GU_length_apic_apic_sd)   # on tire une longueur dans la distribution associee
          while (final_size <5) or (final_size >25):                # si on sort des bornes on tire a nouveau, jusqu'a etre dans les bornes
            final_size=gauss(GU_length_apic_apic_mean,GU_length_apic_apic_sd)
        else:
          final_size=gauss(GU_length_apic_lat_mean,GU_length_apic_lat_sd)
          while (final_size <5) or (final_size >25):
            final_size=gauss(GU_length_apic_lat_mean,GU_length_apic_lat_sd)
        
        # On tire la taille finale des feuilles selon le meme principe    
        final_size_leaf=gauss(Leaf_length_apic_mean,Leaf_length_apic_sd)
        while (final_size_leaf <5) or (final_size_leaf >34):
          final_size_leaf=gauss(Leaf_length_apic_mean,Leaf_length_apic_sd)
      
      # Sinon on est dans le cas lateral    
      else:
        final_size=gauss(GU_length_lat_mean,GU_length_lat_sd)
        while (final_size <5) or (final_size >25):
          final_size=gauss(GU_length_lat_mean,GU_length_lat_sd) 
        
        final_size_leaf=gauss(Leaf_length_lat_mean,Leaf_length_lat_sd)
        while (final_size_leaf <5) or (final_size_leaf >34):
          final_size_leaf=gauss(Leaf_length_lat_mean,Leaf_length_lat_sd)
  
        hypo=final_size*0.38+0.88+randint(-1,1)  #On calcul la longueur de l'espace pre-feuille en fonction de celle de l'UC
      
      # on calcule le nombre de feuilles en fonction de la longueur de l'UC
      NbInternode=int(max(ceil(0.6*final_size)+randint(-1,1) ,1))
      t_ip=gauss(mean_tip_GU,sd_tip_GU)
      
    else:
      cum=delta_temperature_Inflo*pdt
      cumL=0
      final_size=gauss(Inflo_length_mean,Inflo_length_sd)
      final_size_leaf=1
      hypo=0
      t_ip=0
      NbInternode=0
      while (final_size <5) or (final_size >44):
          final_size=gauss(Inflo_length_mean,Inflo_length_sd)
     
    pheno_TTS=pdt*pheno_base_temp_GU[0]
    [pheno_advct_stage,pheno_stage]=normalized_pheno_stage(pheno_TTS,"GU")  #calcul de l'avct ds le stade pheno  
    if length!=None : final_size_GU=length
    param = ParameterSet(burst_date=burst_date,
                         nature=mm.get_nature_gu(mtg, current),
                         cycle =mm.get_unit_cycle(mtg, current), 
                         length=length, 
                         nbdescendants = nbdescendants,
                         radius = estimate_radius(nbdescendants), 
                         mtgid = current,
                         
                         final_size_GU=final_size,
                         final_size_Leaf=final_size_leaf,
                         LEPF=hypo,
                         NbInternode=NbInternode,
                         T_ip=t_ip,
                         
                         cumsum_temp=cum,
                         cumsum_temp_Leaf=cumL,
                         pheno_stage=pheno_stage,
                         pheno_advct=pheno_advct_stage,
                         pheno_TTS=pheno_TTS,
                         age=pdt-1,
                         diam=0)
                         
    # On définit l'UC comme une alternance de feuilles et d'entrenoeuds
    nproduce /(60) GU( param )
    nproduce Internode(ParameterSet(length=0.01,final_size_organ=param.LEPF,diam=0.01)) /(phyllotaxy) 
    nproduce [ &(0) Leaf(ParameterSet(position=0,size=0.1,final_size=param.final_size_Leaf*leaflength(0) )) ]
    
    # On trace les entrenoeuds restants en les espacant de moins en moins, chaque entenoeud suivi d'une feuille
    totintlength=0
    for j in xrange(1,param.NbInternode-1): totintlength+=exp(-2.64*j/float(param.NbInternode-1))
    for i in xrange(1,param.NbInternode-1):        
      nproduce  Internode(ParameterSet(length=0.01,final_size_organ=(param.final_size_GU-param.LEPF)*exp(-2.64*i/float(param.NbInternode-1))/totintlength,diam=0.01)) /(phyllotaxy) 
      nproduce [ &(0) Leaf(ParameterSet(position=i/float(param.NbInternode-1),size=0.1,final_size=param.final_size_Leaf*leaflength(i/float(param.NbInternode-1)) )) ]
    # Fin de l'UC
    nproduce GUEnd
      
      
    children = mm.vegetative_children(mtg, current)
    apical_child = [c for c in children if mm.is_apical(mtg, c)]
    lat_children = [c for c in children if mm.is_lateral(mtg,c)]
    inflo = mm.inflorescence_children(mtg, current)
    nb_lat_children = len(lat_children)
    if nb_lat_children > 0:
      lat_angle = 360./nb_lat_children
    def gu_parameters(gu):
      if mm.get_parent(mtg,mm.get_parent(mtg,gu))!=None:
       p = ParameterSet(mtgid=gu, 
                          nature=mm.get_nature_gu(mtg,gu),
                          position=mm.get_position_gu(mtg,gu), 
                          position_ancestor=mm.get_position_gu(mtg,mm.get_parent(mtg,gu)),
                          nature_ancestor=mm.get_nature_gu(mtg,mm.get_parent(mtg,gu)))
      else:
       p = ParameterSet(mtgid=gu, 
                          nature=mm.get_nature_gu(mtg,gu),
                          position=mm.get_position_gu(mtg,gu), 
                          position_ancestor=1,
                          nature_ancestor=1)
      if mm.has_burst_date(mtg,gu) : p.set(burst_date=mm.get_burst_date(mtg,gu)) 
      return p
    for ch in lat_children:
        nproduce /(lat_angle) [  &(60)
        if mm.get_unit_cycle(mtg, ch) == 3: 
           nproduce B( ch )
        else:  
           nproduce A( gu_parameters(ch) )
        nproduce ]
    if len(apical_child) > 0:
      if len(inflo) > 0:
        final_size_inflo=gauss(Inflo_length_mean,Inflo_length_sd)
        while (final_size_inflo <5) or (final_size_inflo >44):
          final_size_inflo=gauss(Inflo_length_mean,Inflo_length_sd)
        nproduce [Bourgeon_Inflo(ParameterSet(length=0.01,
                                             age=0,
                                             final_size=final_size_inflo,
                                             diam=0.01,
                                             pheno_stage=0,
                                             cumsum_temp=delta_temperature_Inflo*pdt,
                                             pheno_advct=0,
                                             pheno_TTS=0,
                                             mtgid=inflo[0],
                                             bloom_dates=mm.get_bloom_dates(mtg,inflo[0]))) ]
      ch = apical_child[0]
      if mm.get_unit_cycle(mtg, ch) == 3:  nproduce B(ch)
      else:   
        nproduce A( gu_parameters(ch) )
    elif len(inflo) > 0:
        final_size_inflo=gauss(Inflo_length_mean,Inflo_length_sd)
        while (final_size_inflo <5) or (final_size_inflo >44):
          final_size_inflo=gauss(Inflo_length_mean,Inflo_length_sd)
        nproduce Bourgeon_Inflo(ParameterSet(length=0.01,
                                             age=0,
                                             final_size=final_size_inflo,
                                             diam=0.01,
                                             pheno_stage=0,
                                             cumsum_temp=delta_temperature_Inflo*pdt,
                                             pheno_advct=0,
                                             pheno_TTS=0,
                                             mtgid=inflo[0],
                                             bloom_dates=mm.get_bloom_dates(mtg,inflo[0])))
module G
module LeafSets(lradius, age, scale)
module Flower(burst_date,order) # represent flower
module FlowerRepr(day_age,s)
module fleur


Axiom: 
  nproduce  G B(first_uc) #

derivation length: int(nbsteps)
ignore: / &

production:

decomposition:
maximum depth:max(height_max - height_max_3+1,height_max_3+1)

B(current):
    length= 20 - 10*log(mtg.Height(current)+1,height_max)
    generate_elements(current, None, length, nbdescendants[current])

A( p ):
  if  p.burst_date <= current_date :
    generate_elements(p.mtgid, p.burst_date)

production:

#group 0: # pipe model

GU(p) >> x([ GU(pl) ]) GU(pa):
  p.nbdescendants = sum([pli.nbdescendants for pli in pl])+pa.nbdescendants+1
  #p.radius = estimate_radius(p.nbdescendants)
  if p.pheno_stage==4:
    produce GU(p) [ %
  else:
    new_param=p.copy()
    # Mise a jour des parametres pour la croissance
    new_param.age += pdt                                 # on incremente l'age du pas de temps
    [pheno_advct_stage,new_param.pheno_stage]=normalized_pheno_stage(new_param.pheno_TTS,"GU",new_param.pheno_stage)  #calcul de l'avct ds le stade pheno  
      
    # Somme de temperatures pour la croissance
    new_param.cumsum_temp+=delta_temperature_GU*pdt     # on incremente la somme de temperatures cumulees
    
    #Somme de temperature pour les stades pheno
    global temperature      
    delta_temperature_pheno=max(0,temperature[temp_index]-pheno_base_temp_GU[new_param.pheno_stage])
    new_param.pheno_TTS+= delta_temperature_pheno*pdt     # on incremente la somme de temperatures cumulees
    new_param.pheno_advct=pheno_advct_stage
    
    l = GrowthCurve(new_param.cumsum_temp,new_param.final_size_GU,"GU",new_param.final_size_GU,new_param.T_ip)  # calcul de la taille de l'UC
    d = GrowthCurve(new_param.cumsum_temp,final_diamI,"GU",final_diamI,new_param.T_ip)                             # calcul du diametre de l'UC
    new_param.length=l
    new_param.diam=d
    
    # Mise a jour des parametres pour la courbe de croissance  
    global length_inter
    length_inter +=l
    global age_inter
    age_inter=new_param.age
    
    # Recolte des informations sur la croissance de l'UC
    global cumsum_inter
    cumsum_inter=new_param.cumsum_temp
    global pheno_inter
    pheno_inter=new_param.pheno_stage
  produce GU(new_param)


GU(p) >> x([ GU(pl) ]) :
  p.nbdescendants = sum([pli.nbdescendants for pli in pl])+1
  #p.radius = estimate_radius(p.nbdescendants)
  if p.pheno_stage==4:
    produce GU(p) [ %
  else:
    new_param=p.copy()
    # Mise a jour des parametres pour la croissance
    new_param.age += pdt                                 # on incremente l'age du pas de temps
    [pheno_advct_stage,new_param.pheno_stage]=normalized_pheno_stage(new_param.pheno_TTS,"GU")  #calcul de l'avct ds le stade pheno  
      
    # Somme de temperatures pour la croissance
    new_param.cumsum_temp+=delta_temperature_GU*pdt     # on incremente la somme de temperatures cumulees
    new_param.cumsum_temp_Leaf+=delta_temperature_Leaf*pdt     # on incremente la somme de temperatures cumulees pour les feuilles  
    
    #Somme de temperature pour les stades pheno
    global temperature      
    delta_temperature_pheno=max(0,temperature[temp_index]-pheno_base_temp_GU[new_param.pheno_stage])
    new_param.pheno_TTS+= delta_temperature_pheno*pdt     # on incremente la somme de temperatures cumulees
    new_param.pheno_advct=pheno_advct_stage
    
    if not (p.burst_date is None): new_param.length = GrowthCurve(new_param.cumsum_temp,new_param.final_size_GU,"GU",new_param.final_size_GU,new_param.T_ip)  # calcul de la taille de l'UC
    new_param.diam = GrowthCurve(new_param.cumsum_temp,final_diamI,"GU",final_diamI,new_param.T_ip)                             # calcul du diametre de l'UC
    
    # Recolte des informations sur la croissance de l'UC
    global cumsum_inter
    cumsum_inter=new_param.cumsum_temp
    global pheno_inter
    pheno_inter=new_param.pheno_stage
  produce GU(new_param)
  
#GU(p) >> x([ GU(pl) ]) GU(pa):
#  p.nbdescendants = sum([pli.nbdescendants for pli in pl])+pa.nbdescendants+1
#  p.radius = estimate_radius(p.nbdescendants)
#  produce GU(p)

#GU(p) >> x([ GU(pl) ]) :
#  p.nbdescendants = sum([pli.nbdescendants for pli in pl])+1
#  p.radius = estimate_radius(p.nbdescendants)
#  produce GU(p)

consider: GU 
GU(p) < GUEnd:
  if p.pheno_stage ==4:
    produce  ]GUEnd
  else :
    produce GUEnd

GU(p) < Internode(param):
  new_param=param.copy()
  new_param.length = GrowthCurve(p.cumsum_temp,new_param.final_size_organ,"GU",p.final_size_GU,p.T_ip)  # calcul de la taille de l'entrenoeud
  new_param.diam = GrowthCurve(p.cumsum_temp,final_diamI,"GU",final_diamI,p.T_ip)                             # calcul du diametre de l'entrenoeud
  
  # production de l'entrenoeud
  produce Internode(new_param) 

GU(p) < Leaf(param): # Mise a jour des parametres et production de la feuille
  new_param=param.copy()
  new_param.size = GrowthCurve(p.cumsum_temp_Leaf,new_param.final_size,"Leaf",new_param.final_size,0)
  produce Leaf(new_param) 
  
#Bourgeon_Inflo(p):
#  bloom_date = p.bloom_dates[0] if p.bloom_dates else first_date
#  day_age = (current_date - bloom_date).days
#  if day_age < 60:
#    produce Inflorescence(p)
#
#
#  
#Inflorescence(param): # Mise a jour des parametres et production de l'inflorescence
#  new_param=param.copy()
#  new_param.age += pdt
#  [pheno_advct_stage,new_param.pheno_stage,cumtemp]=normalized_pheno_stage(new_param.pheno_TTS,"Inflo",new_param.pheno_stage)  #calcul de l'avct ds le stade pheno  
#  if (new_param.pheno_stage != param.pheno_stage):     # si on change de stade on remet la somme en temps thermique a 0
#    new_param.pheno_TTS=cumtemp
#    
#  # Somme de temperatures pour la croissance
#  new_param.cumsum_temp+= delta_temperature_Inflo*pdt
#    
#  #Somme de temperature pour les stades pheno
#  global temperature      
#  delta_temperature_pheno=max(0,temperature[temp_index]-pheno_base_temp_Inflo[new_param.pheno_stage])
#  new_param.pheno_TTS+= delta_temperature_pheno*pdt     # on incremente la somme de temperatures cumulees
#  new_param.pheno_advct=pheno_advct_stage
#  
#  new_param.length = GrowthCurve(new_param.cumsum_temp,new_param.final_size,"Inflo",new_param.final_size,0)
#  
#  # Mise a jour des parametres pour la courbe de croissance  
#  global length_inter
#  length_inter = new_param.length
#  global age_inter
#  age_inter=new_param.age
#  global pheno_inter
#  pheno_inter=new_param.pheno_stage
#  produce Inflorescence(new_param) 
#

interpretation:
maximum depth:10

# Setup  tropism and legend
# Note that the 2D legend cause a crash of lpy when recording the animation
G : 
  if TIMEBAR:
    ar = False
    envsize = 0.8
    nproduce [ @2D ,(5) @M(-0.85,-0.85) 
    nproduce Label('Tree : '+treename+'. Date: '+str(current_date.year)+'-'+str(current_date.month).zfill(2)+'-'+str(current_date.day).zfill(2)+'. Cycle: '+str(get_cycle(current_date)),14)
    clength = (current_date - first_date).days/float((last_date - first_date).days)
    nproduce ,(4) @M(-0.91,-0.9) -(90) _(0.04) F(0.01)
    if clength > 0:
      nproduce ,(2) @M(-0.9,-0.9) _(0.03) F(clength*envsize)
      nproduce ,(3) @M(-0.9+clength*envsize,-0.9) _(0.04) F(0.01)  
    if clength < 1:
      nproduce ,(4) @M(-0.9+envsize,-0.9) _(0.04) F(0.01)
      nproduce ,(5) @M(-0.9,-0.9) _(0.02) F(envsize)
    nproduce ]
  produce @Tp(0,0,1) @Ts(Elasticity)



A(p) --> ,(3) f(0.1) @O(0.1)

#GU(p):
#  bdate = p.get('burst_date')
#  is_base = (bdate is None)
#  if not is_base:
#    week_age = week_difference(current_date,bdate)
#    produce ,(2) _(p.radius) LeafSets(p.radius, week_age, 1) 
#  else:
#    scale = 1.5
#    produce ,(1) _(p.radius) nF(p.length, p.length/10.) 


#LeafSets(lradius, age, scale):
#  ds = scale / 10.
#  if LEAFY and age < 56 :
#    phy = 137.5
#    nproduce @Gc  F(ds) Leaf(0,lradius, leafsize(0.1), scale ) 
#    nbleaf, dl = (ceil((scale-ds)*5),2*ds)
#    for i in xrange(1,int(nbleaf)):
#      nproduce nF(dl,ds) Leaf(phy*i,lradius, leafsize(0.1+0.1*i ), scale )
#    nproduce F(ds) @Ge
#    for i in xrange(1,4):
#      nproduce Leaf(phy*i,lradius, leafsize(1),scale )
#  else:
#    produce  @Gc nF(1,0.1) @Ge


#Leaf(angle, radius, length, scale ):
#  produce [ /(angle) &(90)  f(radius) @Ge @Gc @v &(10) Sweep(leafpath,leafsection,length*scale,length*scale/10,scale,leafdiam)]

#Inflorescence(p) :
#  bloom_date = p.bloom_dates[0] if p.bloom_dates else first_date
#  print bloom_date
#  day_age = (current_date - bloom_date).days
#  if day_age < 60:
#    produce FlowerRepr(day_age, bloom_date.year + bloom_date.month + bloom_date.day)

#Inflorescence(param):
#   nproduce [   
#   if (param.cumsum_temp>=800):
#     nproduce ,(1) @O(0.01)
#   else:
#    nproduce _(param.length/100.) 
#    NbAxe2=int(1.19*param.final_size)
#    
#    #=====
#    XX=[187525232.]
#    YY=[XX[0]/(2.**32)]
#    
#    for k in xrange(0,NbAxe2):
#      XX.append( (69069.*XX[k]) % (2.**32))
#      YY.append( XX[k+1] / (2.**32))
#    #=====    
#    
#    for k in xrange(0,NbAxe2):
#      nproduce InterpolateColors(13,pheno_color_inflo[param.pheno_stage+1],(param.pheno_advct+param.pheno_stage)*(1-float(k)/NbAxe2) ) 
#      # On choisi la couleur en fonction du stade et de son avancement
#      nproduce F(param.length/NbAxe2,param.length/(NbAxe2*5.))  
#      if (k<8 or k>19): nproduce \(60+(YY[k]*30))
#      else: nproduce \(220)
#      #for d in xrange (0,3):
#      nproduce [@Ts(0.05) @Tp(0,0,1)  +(65) fleur(float(k)/NbAxe2,param.length,max(param.length/10.,param.length*0.687-3.97)*(NbAxe2-k)/NbAxe2,param.pheno_stage,param.pheno_advct)] 
#      #if (i<8 or i>19): nproduce /(60+(YY[k]*30)) \(90)
#   produce ]
#   
#fleur(pos,age,l,pheno,pheno_advct):
#  for k in xrange(0,10):
#      if pos<0.7: nproduce InterpolateColors(13,pheno_color_inflo[pheno+1],(pheno_advct+pheno)*(1-float(k)/10)) 
#      # On choisi la couleur en fonction du stade et de son avancement
#      nproduce F(l/10.,l/100.)  
#      if k>3:
#        for d in xrange (0,3):
#          nproduce [ \(120*d+k*2) +(75) F(l/5*(9-k)/18,0.02),(4) InterpolateColors(pheno_color_flower[pheno],pheno_color_flower[pheno+1],pheno_advct) @O(min(age/100.,0.3))]


#FlowerRepr(day_age,s) :
#  growth_duration = 21.
#  flower_growth_duration = 21.
#  scale = min(1,day_age/growth_duration)
#  if LEAFY:
#    import random as rd
#    rdstate = rd.getstate()
#    rd.seed(s)
#    flower_radius = 0 if day_age < growth_duration else 0.04*min(1,(day_age-flower_growth_duration)/flower_growth_duration)
#    nproduce [
#    if day_age > growth_duration :  nproduce @Tp(0,0,-1) @Ts(inflo_elasticity(min(1,(day_age-growth_duration)/40.))) 
#    nproduce ,(3) _(0.01) F(0.1)
#    nbflower = 4
#    nbelem = int(floor(10 * scale))
#    for i in xrange(10-nbelem,10):
#       nproduce    F(0.1) [ /(rd.randint(0,180))
#       for j in xrange(nbflower):
#           nproduce [ /(j*90)  &(rd.randint(70,110)) F(inflo_radius(i*0.1)) 
#           if flower_radius > 0: nproduce ,(4) @O(flower_radius) 
#           nproduce ]
#       nproduce ]
#    nproduce ,(3) F(0.1)
#    if flower_radius > 0: nproduce ,(4) @O(0.04) 
#    nproduce ]
#    rd.setstate(rdstate)
#  else:
#    scale = 0.3
#    produce ,(4) _(inflo_radius(0))F(scale,inflo_radius(1))
Bourgeon_Inflo(p):
  bloom_date = p.bloom_dates[0] if p.bloom_dates else first_date
  day_age = (current_date - bloom_date).days
  if day_age < 60:
    produce FlowerRepr(day_age, bloom_date.year + bloom_date.month + bloom_date.day)

FlowerRepr(day_age,s) :
  growth_duration = 21.
  flower_growth_duration = 21.
  scale = min(1,day_age/growth_duration)
  if LEAFY:
    import random as rd
    rdstate = rd.getstate()
    rd.seed(s)
    flower_radius = 0 if day_age < growth_duration else 0.04*min(1,(day_age-flower_growth_duration)/flower_growth_duration)
    nproduce [
    if day_age > growth_duration :  nproduce @Tp(0,0,-1) @Ts(inflo_elasticity(min(1,(day_age-growth_duration)/40.))) 
    nproduce ,(3) _(0.01) F(0.1)
    nbflower = 4
    nbelem = int(floor(10 * scale))
    for i in xrange(10-nbelem,10):
       nproduce    F(0.1) [ /(rd.randint(0,180))
       for j in xrange(nbflower):
           nproduce [ /(j*90)  &(rd.randint(70,110)) F(inflo_radius(i*0.1)) 
           if flower_radius > 0: nproduce ,(4) @O(flower_radius) 
           nproduce ]
       nproduce ]
    nproduce ,(3) F(0.1)
    if flower_radius > 0: nproduce ,(4) @O(0.04) 
    nproduce ]
    rd.setstate(rdstate)
  else:
    scale = 0.3
    produce ,(4) _(inflo_radius(0))F(scale,inflo_radius(1))


GU(p):
  is_base = (p.burst_date is None)
  if not is_base:
    if p.pheno_stage==4:
      # on trace l'espace pre_feuille et la premiere feuille
      nproduce _(0.2) F(p.LEPF,0.2) /(phyllotaxy) [ &(0) fLeaf(ParameterSet(position=0,size=p.final_size_Leaf*leaflength(0))) ]
      # On trace les entrenoeuds restants en les espacant de moins en moins, chaque entenoeud suivi d'une feuille
      totintlength=0
      for j in xrange(1,p.NbInternode-1): totintlength+=exp(-2.64*j/float(p.NbInternode-1))
      for i in xrange(1,p.NbInternode-1):
        length=(p.final_size_GU-p.LEPF)*exp(-2.64*i/float(p.NbInternode-1))/totintlength
        nproduce  F(length, 0.2) /(phyllotaxy) [ &(0) fLeaf(ParameterSet(position=i/float(p.NbInternode-1),size=p.final_size_Leaf*leaflength(i/float(p.NbInternode-1)) )) ]
  else:
    scale = 1.5
    produce ,(1) _(p.radius*30) nF(p.length, p.radius*30) 
      
GU(p) < Internode(param):
  is_base = (p.burst_date is None)
  if not is_base:
    if(p.pheno_stage<4):
      produce _(param.diam) F(param.length,param.diam) 

      
fLeaf(param):
  nproduce @G ,(2) [ /(137.5) &(90) ,(1)  f(0) F(0.001,leafdiam(0)*leafwidth(1))  ^(90) 
  # On trace le petiole
  nproduce &(pheno_angle[4]) SetGuide(petioleCurve,(1-param.position)* param.size/4.) @G  Petiole((1-param.position)* param.size/4.,leafdiam(0))  
  # On choisi la couleur   
  nproduce ,(13) @Gc _(leafdiam(0.5))  Sweep(axis5,leafsection, param.size, param.size/10., param.size*0.24, leafdiam) ]  

GU(paramI) < Leaf(paramL) :
 is_base = (paramI.burst_date is None)
 if not is_base:
  if(paramI.pheno_stage<4):
    nproduce @G ,(2) [ /(137.5) &(90) ,(1)  f(0) F(0.001,leafdiam(0)*leafwidth(min((paramI.cumsum_temp_Leaf+1)/378.,1)))  ^(90) 
    # On va chercher les angles correspondants au debut du stade pheno et du stade pheno suivant et on interpole 
    nproduce &((1-paramI.pheno_advct)*pheno_angle[paramI.pheno_stage]+paramI.pheno_advct*pheno_angle[paramI.pheno_stage+1]) 
    # On trace le petiole
    nproduce SetGuide(petioleCurve,(1-paramL.position)* paramL.size/4.) @G 
    nproduce  Petiole(max(0.01,(1-paramL.position)* paramL.size/4.),leafdiam(0)*leafwidth(min((paramI.cumsum_temp_Leaf+1)/378.,1)))  
    # On choisi la couleur en fonction du stade et de son avancement
    nproduce InterpolateColors(pheno_color[paramI.pheno_stage],pheno_color[paramI.pheno_stage+1],paramI.pheno_advct)    
    # On cherche la courbure de feuille correspondant a l'avancement et on trace la feuille
    nproduce @Gc _(leafdiam(paramI.diam))  Sweep(axisfunc.getAt(min(1,(paramI.pheno_stage+paramI.pheno_advct)/(Nb_stades_pheno-2))),leafsection, paramL.size, paramL.size/10., (paramL.size*0.24)*leafwidth(min((paramI.age+1)/20.,1)), leafdiam) ]  

Petiole(length,radius):
  for i in xrange(10):
    nproduce F(length/10.,radius)

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	Color_1 = pgl.Material("Color_1" , ambient = (71,91,46) , diffuse = 1.67033 , )
	Color_1.name = "Color_1"
	context.turtle.setMaterial(1,Color_1)
	Color_7 = pgl.Material("Color_7" , ambient = (62,125,20) , diffuse = 2.04 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	Color_8 = pgl.Material("Color_8" , ambient = (78,102,23) , diffuse = 1.50437 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	Color_9 = pgl.Material("Color_9" , ambient = (70,113,21) , diffuse = 1.77218 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	Color_10 = pgl.Material("Color_10" , ambient = (95,79,27) , diffuse = 0.968421 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	Color_11 = pgl.Material("Color_11" , ambient = (121,46,33) , diffuse = 0.165289 , )
	Color_11.name = "Color_11"
	context.turtle.setMaterial(11,Color_11)
	Color_12 = pgl.Material("Color_12" , ambient = (60,60,15) , diffuse = 3 , )
	Color_12.name = "Color_12"
	context.turtle.setMaterial(12,Color_12)
	Color_13 = pgl.Material("Color_13" , ambient = (30,60,10) , diffuse = 1.68333 , )
	Color_13.name = "Color_13"
	context.turtle.setMaterial(13,Color_13)
	Color_14 = pgl.Material("Color_14" , ambient = (55,60,14) , diffuse = 3 , )
	Color_14.name = "Color_14"
	context.turtle.setMaterial(14,Color_14)
	Color_15 = pgl.Material("Color_15" , ambient = (159,235,97) , diffuse = 0.680851 , )
	Color_15.name = "Color_15"
	context.turtle.setMaterial(15,Color_15)
	Color_16 = pgl.Material("Color_16" , ambient = (255,82,108) , diffuse = 0.627451 , )
	Color_16.name = "Color_16"
	context.turtle.setMaterial(16,Color_16)
	Color_20 = pgl.Material("Color_20" , ambient = (0,0,0) , diffuse = 14.5455 , )
	Color_20.name = "Color_20"
	context.turtle.setMaterial(20,Color_20)
	context.animation_timestep = 0.001
	scalars = [('TREE', 'Integer', 0, 0, 4), ('Geometry', 'Category'), ('LEAFY', 'Bool', True), ('Elasticity', 'Float', 0.03, 0.0, 1.0, 2), ('TIMEBAR', 'Bool', False), ('daystep', 'Integer', 1, 1, 100)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
	import openalea.plantgl.all as pgl
	leafsize = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.431282, 1),(0.324129, 0.436757, 1),(0.408886, 0.416427, 1),(0.412274, 0.708684, 1),(0.844357, 0.703533, 1),(1, 0.246499, 1)]) , 
	    )
	leafsize.name = "leafsize"
	import openalea.plantgl.all as pgl
	axis1 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.5, 0, 1),(-0.166667, 0, 1),(0.214286, 0.00865801, 1),(0.45671, 0.138528, 1)]) , 
	    )
	axis1.name = "axis1"
	axis2 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.5, 0, 1),(-0.166667, 0, 1),(0.209957, -0.017316, 1),(0.491342, -0.0952381, 1)]) , 
	    )
	axis2.name = "axis2"
	axis3 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.5, 0, 1),(-0.166667, 0, 1),(0.166667, 0, 1),(0.5, 0, 1)]) , 
	    )
	axis3.name = "axis3"
	axis4 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.5, 0, 1),(-0.158009, -0.047619, 1),(0.166667, 0.004329, 1),(0.443723, -0.393939, 1)]) , 
	    )
	axis4.name = "axis4"
	axis5 = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.416733, 0.0128104, 1),(0.2343, -0.076231, 1),(0.507411, -0.330906, 1),(0.662132, -0.814102, 1)]) , 
	    )
	axis5.name = "axis5"
	leaflength = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 1, 1),(0.00149779, 1.00072, 1),(1, 0.995671, 1),(1, 0.400121, 1)]) , 
	    )
	leaflength.name = "leaflength"
	petioleCurve = pgl.BezierCurve2D(	
	    pgl.Point3Array([(-0.543785, 0.192006, 1),(-0.178289, 0.176044, 1),(-0.0656355, 0.0728558, 1),(0.548469, 0.597983, 1),(0.397151, 0.581459, 1),(0.543571, 0.599108, 1)]) , 
	    )
	petioleCurve.name = "petioleCurve"
	leafwidth = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.0123039, 1),(0.289062, 0.0763736, 1),(0.289062, 0.454469, 1),(0.331839, 0.989763, 1),(1, 1, 1)]) , 
	    )
	leafwidth.name = "leafwidth"
	leafpath = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.5, 0, 1),(-0.145022, -0.0735931, 1),(0.0844156, -0.212121, 1),(0.123377, -0.497835, 1)]) , 
	    )
	leafpath.name = "leafpath"
	inflo_elasticity = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.0278664, 1),(0.341991, 0.034632, 1),(0.675325, 0.04329, 1),(1, 0.252183, 1)]) , 
	    )
	inflo_elasticity.name = "inflo_elasticity"
	leafsection = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(-0.508209, 0.16873, 1),(-0.515031, 0.138195, 1),(-0.198373, -0.0924227, 1),(-0.00298323, 0.188761, 1),(0.0897461, -0.106293, 1),(0.555704, 0.0979703, 1),(0.545047, 0.12817, 1)]) , 
	    )
	leafsection.name = "leafsection"
	leafdiam = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.0846264, 1),(0.239002, 1.00091, 1),(0.485529, 0.991241, 1),(0.718616, 1.00718, 1),(0.877539, 0.231273, 1),(1, 0.00332359, 1)]) , 
	    )
	leafdiam.name = "leafdiam"
	inflo_radius = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.160173, 1),(0.393939, 0.151515, 1),(0.735931, 0.0649351, 1),(1, 0.025974, 1)]) , 
	    )
	inflo_radius.name = "inflo_radius"
	radius_base03 = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.131507, 1),(0.00454138, 0.0251277, 1),(0.578848, 0.00694723, 1),(1, 0.00524218, 1)]) , 
	    )
	radius_base03.name = "radius_base03"
	radius = pgl.NurbsCurve2D(	
	    ctrlPointList = pgl.Point3Array([(0, 0.107326, 1),(0.192635, 0.0975655, 1),(0.457142, 0.000244746, 1),(1, 0.026087, 1)]) , 
	    )
	radius.name = "radius"
	panel_0 = ({'active': True, 'visible': True, 'name': 'Panel 2'},[('Function',leafsize),('Curve2D',axis1),('Curve2D',axis2),('Curve2D',axis3),('Curve2D',axis4),('Curve2D',axis5),('Function',leaflength),('Curve2D',petioleCurve),('Function',leafwidth),('Curve2D',leafpath),('Function',inflo_elasticity),('Curve2D',leafsection),('Function',leafdiam),('Function',inflo_radius),('Function',radius_base03),('Function',radius)])
	parameterset = [panel_0,]
	context["__functions__"] = [('leafsize',leafsize),('leaflength',leaflength),('leafwidth',leafwidth),('inflo_elasticity',inflo_elasticity),('leafdiam',leafdiam),('inflo_radius',inflo_radius),('radius_base03',radius_base03),('radius',radius),]
	context["__curves__"] = [('axis1',axis1),('axis2',axis2),('axis3',axis3),('axis4',axis4),('axis5',axis5),('petioleCurve',petioleCurve),('leafpath',leafpath),('leafsection',leafsection),]
	context["__parameterset__"] = parameterset
	context["leafsize"] = pgl.QuantisedFunction(leafsize)
	context["axis1"] = axis1
	context["axis2"] = axis2
	context["axis3"] = axis3
	context["axis4"] = axis4
	context["axis5"] = axis5
	context["leaflength"] = pgl.QuantisedFunction(leaflength)
	context["petioleCurve"] = petioleCurve
	context["leafwidth"] = pgl.QuantisedFunction(leafwidth)
	context["leafpath"] = leafpath
	context["inflo_elasticity"] = pgl.QuantisedFunction(inflo_elasticity)
	context["leafsection"] = leafsection
	context["leafdiam"] = pgl.QuantisedFunction(leafdiam)
	context["inflo_radius"] = pgl.QuantisedFunction(inflo_radius)
	context["radius_base03"] = pgl.QuantisedFunction(radius_base03)
	context["radius"] = pgl.QuantisedFunction(radius)
